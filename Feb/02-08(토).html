<!DOCTYPE html>
<html>
<head>
<title>02-08(토).md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="0208%ED%86%A0-%EA%B0%95%EC%9D%98-%EB%85%B8%ED%8A%B8">02_08(토) 강의 노트</h1>
<ul>
<li>
<p>데이터의 분포(패턴)를 찾아서 의미있는 결론을 도출 -&gt; 통계의 목표</p>
<ul>
<li>then ai is statistics</li>
<li>statistics is math</li>
<li>so AI == MATH</li>
</ul>
</li>
<li>
<p>수학 : 추상적인 개념을 탐구하고 논리적으로 확장하는 것 - 함수, 대수, 위상 수학</p>
<ul>
<li>추상적 구조를 연구하고 연산의 성질을 정의</li>
<li>엄밀한 증명을 통해 개념의 타당성을 보장</li>
</ul>
</li>
<li>
<p>컴퓨터 공학 : 구체적인 연산과 시스템을 설계하는 것 - 알고리즘, 데이터 구조, 컴파일러</p>
<ul>
<li>but, 컴퓨터 과학도 본질적으로 수학을 기반으로 하며, 기초적인 개념부터 시작하여 다양한 응용 분야로 확장된다.</li>
<li>연산을 자동화하고 연산을 효율적으로 하는 것이 컴퓨터 공학의 목표</li>
</ul>
</li>
<li>
<p>즉, 수학은 주로 추상적 사고를 기반으로 발전하며, 컴퓨터 과학은 이를 구체적 구현으로 변환하는 역할을 함.</p>
</li>
<li>
<p>따라서, 수학을 아는 것이 중요</p>
</li>
<li>
<p>수학적 사고의 세 단계</p>
<ul>
<li>
<ol>
<li>기초 : 문제 해결을 위한 기본적인 원리</li>
</ol>
<ul>
<li>대수, 집합론 등</li>
</ul>
</li>
<li>
<ol start="2">
<li>응용 : 기존 개념을 발전시키고 실생활에 적용</li>
</ol>
<ul>
<li>통계학, 데이터과학 등</li>
</ul>
</li>
<li>
<ol start="3">
<li>창발 : 기존 개념에서 새로운 개념이 자연스럽게 등장</li>
</ol>
<ul>
<li>머신러닝에서 뉴럴 네트워크가 나온것</li>
</ul>
</li>
</ul>
</li>
<li>
<p>수학적 사고에서 가장 중요한 개념, 즉 수학적 대상은</p>
<ul>
<li>집합 : 관심 있는 수학적 대상(수,함수,행렬 등)의 모임
<ul>
<li>무한 혹은 유한일 수 있으며 아무 요소도 없는 공집합과 하나의 요소만 있는 singleton이 있다.</li>
<li>부분집합 : 특정 조건을 막족하는 원소들의 집합</li>
<li>멱집합 : 어떤 집합의 공집합을 포함한 모든 부분집합의 모임</li>
</ul>
</li>
<li>함수 : 집합 X에서 집합 Y로의 함수란, 집합 X의 각 원소를 정확히 하나의 Y의 원소에 대응시키는 규칙을 의미한다.
<ul>
<li>이때, 집합 X를 정의역(domain), 집합 Y를 공역(codomain)이라고 한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>수학에서 다루는 주요 대상들은 집합의 형태로 정의되잠ㄴ 단순한 원소들의 모임이기 때문에, 원소들 사이에 관계나 연산이 존재하지 않는 무질서한 상태이다.</p>
</li>
<li>
<p>여기에 연산과 성질(두 원소를 받아 새로운 원소를 반호나하는 규칙)을 추가하면 <code>수학적 구조</code> 가 형성된다.
$$수학적 구조 = (집합, 연산, 공리)$$
즉, 집합에 특정한 연산을 추가하고, 이 연산이 만족해야한 공리(무조건 지켜야하는 조건 혹은 명제)를 설정하면 구조가 정의 된다.
예를 들어,
- 집합 + 이항연산(덧셈, 곱셈) =&gt; 대수구조</p>
<ul>
<li>대수구조에 대하여 구체적으로 얘기하자면 비어있지 않은 집합 A(기본집합 또는 정의역) + 집합 A위에서 정의된 연산들의 모음 + 연산들이 반드시 만족해야하는 유한개의 항등식(공리)로 구성된다.
그러면, 벡터공간에는 어떤 연산이 추가된것일까?
<ul>
<li>벡터 덧셈</li>
<li>스칼라 곱</li>
</ul>
</li>
<li>벡터들의 모임이 집합이고 여기에 두가지 연산(벡터 덧셈, 스칼라 곱)을 추가해야 벡터공간이 되는 것이다.</li>
<li>또한 이에 따라 벡터 공간에서 지켜야하는 공리는 다음과 같다.
<ul>
<li>
<ol>
<li>교환법칙</li>
</ol>
<ul>
<li>$u+v=v+u,  \ \ ∀u,v∈V$</li>
</ul>
</li>
<li>
<ol start="2">
<li>결합법칙</li>
</ol>
<ul>
<li>$(u+v)+w=u+(v+w), \ \ ∀u,v,w∈V$</li>
</ul>
</li>
<li>
<ol start="3">
<li>덧셈 항등원 존재</li>
</ol>
<ul>
<li>$∃0∈V such that v+0=v, \ \ ∀v∈V$</li>
</ul>
</li>
<li>
<ol start="4">
<li>덧셈 역원 존재</li>
</ol>
<ul>
<li>$∀v∈V,∃−v∈V \ \  such that v+(−v)=0$</li>
</ul>
</li>
<li>
<ol start="5">
<li>분배법칙 - 벡터 덧셈</li>
</ol>
<ul>
<li>$a(u+v)=au+av,\ \ ∀u,v∈V,a∈F$</li>
</ul>
</li>
<li>
<ol start="6">
<li>분배법칙 - 스칼라 덧셈</li>
</ol>
<ul>
<li>$(a+b)v=av+bv,\ \ ∀v∈V,a,b∈F$</li>
</ul>
</li>
<li>
<ol start="7">
<li>결합법칙 - 스칼라 곱</li>
</ol>
<ul>
<li>$a(bv)=(ab)v,\ \ ∀v∈V,a,b∈F$</li>
</ul>
</li>
<li>
<ol start="8">
<li>항등원 존재 - 스칼라</li>
</ol>
<ul>
<li>$1v=v,\ \ ∀v∈V$</li>
</ul>
</li>
</ul>
</li>
<li>벡터공간이라는 대수구조를 다음과 같은 <code>튜플</code>로도 표현할 수 있다.
$$(V,+,\cdot)$$</li>
<li>즉, 벡터 공간은 벡터 공간은 <code>집합 + 연산(벡터 덧셈, 스칼라 곱) + 공리(8개)</code>로 이루어진 수학적 구조이다.</li>
</ul>
</li>
<li>
<p>More into 대수구조
<img src="image-3.png" alt="alt text"></p>
</li>
<li>
<p>마그마(Magma)</p>
<ul>
<li>집합 $S$ 와 하나의 이항연산 $*$ 이 정의됨.</li>
<li>연산의 폐쇄성이 존재
$$
a, b \in S \Rightarrow a * b \in S
$$</li>
<li>즉, 예를 들어 자연수 집합 $\mathbb{N}$ 위에서 덧셈 연산 $(+)$ 을 수행하면 항상 자연수로 닫혀 있음.</li>
<li>여기서 $*$은 덧셈 and 곱셈</li>
</ul>
</li>
<li>
<p>반군(Semigroup)</p>
<ul>
<li>마그마에 결합법칙이 추가됨.
$$
(a * b) * c=a *(b * c), \  \forall a,b,c \in S
$$</li>
</ul>
</li>
<li>
<p>모노이드(Monoid)</p>
<ul>
<li>반군에 항등원이 추가됨.
$$
e * a=a * e=a, \  \forall a \in S
$$</li>
</ul>
</li>
<li>
<p>군(Group)</p>
<ul>
<li>모노이드에 역원이 추가됨.
$$
\forall a \in S, \exists a^{-1} \ \text { such that } a * a^{-1}=e
$$</li>
<li>군에 교환법칙을 추가하면 아벨 군(Abelian Group,가환군)이다.
$$
a * b = b * a, \ \forall a,b \in G
$$</li>
</ul>
</li>
<li>
<p>환(Ring)</p>
<ul>
<li>두 개의 이항 연산(덧셈,곱셈)이 정의된 대수적 구조</li>
<li>덧셈 가환군
<ul>
<li>즉 덧셈에 대해 교환, 결합, 항등원, 역원</li>
</ul>
</li>
<li>곱셈 모노이드
<ul>
<li>즉, 곱셈에 대해 결합, 항등원(항등원 존재 여부에 따라 단위원을 갖는 환과 그렇지 않은 환으로 구분)</li>
</ul>
</li>
<li>분배법칙(곱셈, 덧셈)
<ul>
<li>즉, 덧셈과 곱셈 사이에 분배법칙이 존재한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>채(field)</p>
<ul>
<li>환의 확장판으로 나눗셈을 할 수 있다.(즉, 곱셈에 대해 역원이 존재한다.)
$$
\forall a \in F, a \neq 0, \quad \exists a^{-1} \text { such that } a \times a^{-1}=1
$$</li>
</ul>
</li>
<li>
<p>예시를 들어보면 다음과 같다.
$$
\begin{gathered}
(\mathbb{Z},+)=G ? \text{ =&gt; 정수 집합 Z에 덧셈 연산을 정의하면 아벨 군이 된다.}\
(\mathbb{Z}, \times) \neq G \text{ =&gt; 정수 집합 Z에 곱셈 연산을 정의하면 군을 이루지 못한다.} \
(\mathbb{Q}, \times)=G \text{ =&gt; 유리수 집합 Q에서 곱셈를 정의하면 군을 이룬다.} \
(\mathbb{Z},+, \times)=R \text{ =&gt; 정수에 덧셈과 곱셈 연산이 함께 정의 되면 환이 된다.}\
(\mathbb{Q},+, \times),(\mathbb{R},+, \times),(\mathbb{C},+, \times)=F \text{=&gt; 유리수, 실수, 복소수 집합에서 덧셈과 곱셈을 함계 고려하면 체가 된다. }
\end{gathered}
$$</p>
</li>
<li>
<p>why?</p>
<ul>
<li>
<ol>
<li>정수는 덧셈에 대해 교환법칙이 성립함</li>
</ol>
</li>
<li>
<ol start="2">
<li>정수는 곱세에 대해 역원이 존재하지 않고 0이 포함된 군이라면 영원의 문제가 존재하지</li>
</ol>
</li>
<li>
<ol start="3">
<li>0을 제외한 유리수 집합에서 곱셈을 정의하면 군을 이룸</li>
</ol>
</li>
<li>
<ol start="4">
<li>정수는 덧셈에 대하여 역원이 존재하지만 곱셈에 대한 역원이 없으므로 체는 될 수 없지만 환에 해당함</li>
</ol>
</li>
<li>
<ol start="5">
<li>but 유리수, 실수, 복소수 집합에서 덧셈과 곱셈을 함께 고려하면 체가 된다.</li>
</ol>
<ul>
<li>덧셈에 대해 아벨 군, 곱셈에 대해 아벨 군 그리고 분배법칙이 성립한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>다시 벡터공간으로 돌아가보면, 벡터 공간은 벡터 공간은 <code>집합 + 연산(벡터 덧셈, 스칼라 곱) + 공리(8개)</code>로 이루어진 수학적 구조인데,
이를 다시 구체적으로 정의해보면 다음과 같다.
$$
\begin{gathered}
+: V \times V \to V, \quad \text{(벡터 덧셈)} \
\cdot: F \times V \to V, \quad \text{(스칼라 곱)} \
(V, F, +, \cdot) = \operatorname{Module}(\text{Ring}) \
\text{where } V \text{ is a vector space, and } F \text{ is a field (e.g., } \mathbb{R}, \mathbb{C} \text{).}
\end{gathered}
$$</p>
<ul>
<li>V는 벡터들의 집합이며, 덧셈이 정의되고 F는 체를 의미하며 실수체 $\mathbb{R}$ 또는 복소수체 $\mathbb{C}$를 의미함.</li>
<li>벡터 공간은 이렇게 벡터의 덧셈과 스칼라 곱이 정의 된 대수구조임.</li>
<li>여기서 모듈(Module)은 환 위에서 정의된 일반적 개념인데, 벡터 공간은 체 위에서 정의된 특수한 모듈이다.</li>
<li>즉, 모든 벡터 공간은 체 위에서 정의되어 모듈이지만 모든 모듈이 벡터공간은 아니다.
<ul>
<li>ex) 모듈에서는 스칼라의 역원이 존재하지 않을 수 있다.</li>
</ul>
</li>
</ul>
<p>근데 왜 벡터 공간은 공간이라고 부를까?</p>
<ul>
<li>
<p>수학적 공간이란?</p>
<ul>
<li>원소들이 특정한 관계(구조)를 가지면서 존재하는 수학적 환경</li>
<li>근데 왜 공간이라 부를까?
<ul>
<li>단순한 대수 구조를 넘어서 공간적인 성질(거리,위상,차원)을 가질 수 있기 때문에 공간이라는 용어를 사용함,벡터라는 원소 자체의 특성때문이기도함.</li>
<li>즉, 벡터 공간은 기학학적 개념과 자연스럽게 연결될 수 있는 대수적 구조가 공간을 형성하기 때문에 벡터 공간이라하는 것이다.
<ul>
<li>
<ol>
<li>벡터 공간은 방향과 크기를 표현가능하다.</li>
</ol>
</li>
<li>
<ol start="2">
<li>내적이 정의된 벡터공간은 벡터간 거리와 각도를 정의할 수 있음.</li>
</ol>
</li>
<li>
<ol start="3">
<li>내적이 추가된 벡터 공간에서는 기저를 통해 차원의 개념을 정의할 수 있음</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>그러면 벡터공간이 내적 공간이 될려면 어떠한 연산이 추가되는 것일까?</p>
<ul>
<li>내적이란 무엇일까?
<ul>
<li>내적이란 벡터 공간에서 두 벡터 사이의 관계를 정량화(스칼라화)하는 함수</li>
<li>이는 두 벡터간의 유사성을 나타낸다. 기하학적으로 각도와 놈의 개념을 표현한다.</li>
</ul>
</li>
<li>내적을 정의하는 함수는 하나만 있을까?
<ul>
<li>아니다. 내적은 벡터 공간의 특성에 따라 다르게 정의될 수 있으며, 내적의 4가지 공리를 만족하는 다양한 형태의 함수가 존재한다.
$$\langle\cdot, \cdot\rangle: V \times V \rightarrow F$$
<ul>
<li>내적함수$\langle \cdot,\cdot \rangle$는 벡터 공간 V에서 두 벡터를 입력으로 받아, Field F의 원소(Scalar) 값을 출력하는 함수이다.</li>
</ul>
</li>
<li>내적의 공리
<ul>
<li>
<p>Conjugate Symmetry (켤레 대칭성)</p>
<ul>
<li>두 벡터의 내적은 교환 가능하다.</li>
<li>따라서, 실수 벡터 공간에서는 단순한 대칭성을 만족한다.<br>
$$
\langle u, v \rangle = \langle v, u \rangle
$$</li>
<li>다만, 복소수 벡터 공간에서는 켤레 복소수 관계를 가진다.<br>
$$
\langle u, v \rangle = \overline{\langle v, u \rangle}, \quad \forall u, v \in V
$$</li>
</ul>
</li>
<li>
<p>Linearity in the First Argument (첫 번째 변수에 대한 선형성)</p>
<ul>
<li>첫 번째 변수에 대해 선형 연산을 유지한다.<br>
$$
\langle a u + b w, v \rangle = a \langle u, v \rangle + b \langle w, v \rangle, \quad \forall u, w, v \in V, \quad \forall a, b \in \mathbb{F}
$$</li>
</ul>
</li>
<li>
<p>Positive Definiteness (양의 정부호성)</p>
<ul>
<li>벡터 자기 자신과의 내적은 항상 0 이상이며, 벡터가 0벡터가 아닌 경우 내적값은 반드시 양수여야 한다.<br>
$$
\langle v, v \rangle \geq 0, &amp; \langle v, v \rangle = 0  \text{ then} v = 0
$$</li>
</ul>
</li>
<li>
<p>Homogeneity in the First Argument (첫 번째 변수에 대한 동질성, 균질성)</p>
<ul>
<li>스칼라 배율이 그대로 유지된다.<br>
$$
\langle a u, v \rangle = a \langle u, v \rangle, \quad \forall a \in \mathbb{F}, \quad \forall u, v \in V
$$</li>
</ul>
</li>
</ul>
</li>
<li>따라서, 유클리드 공간의 유클리드 내적, 복소수 공간의 복소수 내적 등 다양한 내적이 존재한다.
<ul>
<li>그러면 유클리드 공간의 스칼라 체는 무엇일까?
<ul>
<li>유클리드 공간은 스칼라 연산이 실수에서 이루어지기 때문에 스칼라체는 실수체이며 따라 실수체 위의 유한 차원의 내적공간으로 정의된다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>벡터 공간의 확장
벡터 공간 -&gt; 길이, 거리 개념이 없음
=&gt; 내적을 추가 =&gt; 내적 공간 -&gt; 내적을 추가하여 각도, 투영, 직교를 정의할 수 있음
=&gt; 내적으로부터 놈을 정의 =&gt; 놈 공간 -&gt; 내적으로부터 벡터의 길이(norm)을 정의할 수 있음
=&gt; 놈으로부터 거리를 정의 =&gt; 거리 공간 -&gt; norm을 통해 벡터 간의 거리 개념을 정의할 수 있음
=&gt; 거리로부터 열린 집합을 정의 =&gt; 위상 공간 -&gt; <code>거리 기반으로 열린 집합을 정의하여 위상을 형성할 수 있음...? -&gt; 이해 부족</code></p>
</li>
<li>
<p>벡터 공간을 정의할때 차원이란 무엇일까?</p>
<ul>
<li>
<p>벡터 공간을 생성(Span)하는 선형 독립인 벡터들의 집합(기저, Basis)의 원소 개수</p>
</li>
<li>
<p>이는 벡터 공간의 기본 구조를 결정하는 중요한 속성이다.</p>
</li>
<li>
<p>그렇다면 차원을 정의할때 기저란 무엇일까?</p>
<ul>
<li>선형 독립성을 가지며 벡터 공간 전체를 생성하는 벡터들의 집합 =&gt; 즉, 벡터 공간을 전부 커버할 수 있는 독립적인 방향을 가진 벡터들의 집합을 뜻한다.</li>
<li>즉, 벡터지만 선형 독립성이라는 특성이 추가된 벡터 집합의 부분 집한이다. 또한 이 것들의 개수로 해당 공간의 차원이 결정된다.</li>
<li>그러면 선형 독립성이란?
<ul>
<li>해당 벡터 집합의 어떠한 벡터도 나머지 벡터들의 선형 결합으로 표현될 수 없다는 것을 의미</li>
<li>다른말로는 해당 벡터 집합의 선형결합으로 해당 벡터 공간의 모든 벡터들을 표현할 수 있다는 의미이다.</li>
</ul>
</li>
<li>하나의 공간에 기저는 하나뿐일까?
<ul>
<li>아니다. 해당 공간에서 기저의 두 조건을 만족하는 벡터들은 기저에 해당한다. but 모든 기저(집합)은 같은 원소의 개수를 가진다.</li>
<li>기저의 조건
<ul>
<li>
<ol>
<li>선형 독립 (Linear Independence)
집합 $B$ 가 선형 독립이라는 것은, $B$ 의 모든 유한 부분집합이 선형 독립이어야 한다는 의미이다.
즉, 임의의 유한 부분집합 $\left{v_1, v_2, \ldots, v_m\right} \subset B$ 에 대해,</li>
</ol>
<p>$$
c_1 v_1+c_2 v_2+\cdots+c_m v_m=0
$$</p>
<p>을 만족하는 스칼라 $c_1, c_2, \ldots, c_m \in F$ 가 존재할 때,</p>
<p>$$
c_1=c_2=\cdots=c_m=0
$$
이어야 한다.
즉, 기저의 원소들은 서로 종속되지 않고 독립적인 방향을 가진다.</p>
</li>
<li>
<ol start="2">
<li>생성(Spanning Property)</li>
</ol>
<p>기저 $B$ 는 벡터 공간 $V$ 의 생성 집합(Spanning Set)이어야 한다.
즉, 임의의 벡터 $v \in V$ 는 기저 $B$ 의 유한한 선형 결합(Linear Combination)으로 표현할 수 있어야 한다.</p>
<p>즉, 임의의 벡터 $v \in V$ 에 대해, 적절한 스칼라 $a_1, a_2, \ldots, a_n \in F$ 와 벡터 $v_1, v_2, \ldots, v_n \in B$ 가 존재하여</p>
<p>$$
v=a_1 v_1+a_2 v_2+\cdots+a_n v_n
$$
즉, 기저 벡터들을 독립적인 방향을 지녀야한다.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>기저를 정의하는 방식에 하나 더 있다. 과연?
<ul>
<li>해당 정의를 가지고 기저를 정의한다면 벡터 공간의 기저는 체 F(스칼라) 위에서 정의된 벡터들의 선형 독립 집합으로, 벡터 공간 V를 생성(Span)하는 집합.</li>
</ul>
</li>
<li>그렇다면 모든 벡터 공간에는 기저가 있을까?(심지어 무한 차원에서도?)
<ul>
<li>우선 기저의 공리를 생각해본다면 유한 차원에서는 기저가 항상 존재한다.
<ul>
<li>예를 들어, n차원 공간에서는 $(e_1,e_2,...,e_n)$ 에서 하나만 1이고 나머지 0인 서로 다른 n개의 벡터들이 유한 차원 공간에서 기저가 될 수 있다.</li>
<li>그렇다면 무한차원에서는?
<ul>
<li>위의 $(e_1,e_2,...,e_n)$를 $n \to \infty$라 확장한다면 무한 공간에서 까지 존재하여 항상 존재한다고 할 수 있지만 엄밀한 정의인지는 모르겠다....</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>수학에서 말하는 벡터공간의 차원과 numpy에서 말하는 차원에는 무슨 차이가 있을까?</p>
<ul>
<li>v = (1, 2, 3) =&gt; dim V = 3  -&gt; math</li>
<li>M_(2xx2) = [1, 2; 3, 4] -&gt; in numpy &lt;=&gt; m = (1, 2, 3 ,4) in M =&gt; dim M = 4 -&gt; in math</li>
<li>수학적 차원과 달리 numpy에서 차원이란 수학의 텐서의 차수, 랭크를 의미한다.</li>
<li>numpy의 reshape은 벡터 공간의 차원을 보존한다.</li>
<li>또한 numpy의 size는 벡터 공간의 차원을 알려준다.</li>
<li>이를 통해 알 수 있는 것은 수학은 맥락속에서 파악해야한다는 것이다.</li>
</ul>
</li>
</ul>
</li>
</ul>

</body>
</html>
