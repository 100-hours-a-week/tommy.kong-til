# 금일 목표
1. Numpy에 대한 추가학습
2. 시간이 있으면 pandas에 대한 추가학습도 진행

---
# 학습 노트
# Numpy
- 라이브러리를 처음 배울때 공식 문서를 보는 것도 좋은 방법이다. 왜냐하면, 개발자가 직접 작성한 정통성 있는 자료이기 때문.

- WebAssembly(WASM): 브라우저에서 JavaScript를 뛰어넘는 고성능 프로그램 실행 가능
- WebGPU: 웹에서 GPU를 활용한 고성능 연산 가능

- I/O -> 파일 입출력을 뜻함. 대용량 수치 데이터를 빠르게 불러 오기위하여 다양한 방식이 존재함.

## ndarray 복습
- numpy의 핵심은 ndarray
- ndarray란?
  - 고정된 크기의 항목들로 이루어진 다차원 동질 배열 객체
  - 각 요소의 형식은 데이터 타입 객체를 통해 설명

- ndarray의 제약사항
  - 모든 요소는 동일한 데이터타입을 가져야한다.
  - 한번 생성되면 크기는 바꿀 수 없다.
  - 배열은 직사각형의 형태여야한다.

- ndarray의 속성
```python
array_example = np.array([[[0, 1, 2, 3],
                           [4, 5, 6, 7]],

                          [[0, 1, 2, 3],
                           [4, 5, 6, 7]],

                          [[0 ,1 ,2, 3],
                           [4, 5, 6, 7]]])
```
- 차원 : 3 -> 축의 개수
- 크기 : 24 -> 요소의 개수
- 모양 : (3,2,4) -> array의 속성을 튜플형태로 나타낸 값

- Deep copy vs Shallow copy 
```python
a = [1, 2, 3]
b = a
print(b)
>> [1, 2, 3]
b[0] = 2
print(b)
>> [2, 2, 3]
print(a)
>> [2, 2, 3]
```
- 얕은 복사: 같은 객체를 가리킴 (메모리 주소 동일) → b[0] = 2 하면 a도 변함
- 깊은 복사: 새로운 객체를 생성 (메모리 주소 다름) → b[0] = 2 해도 a는 원래 유지됨
  -  `copy.deepcopy(a)`을 통해 가능


- Slicing and striding
- numpy에서 view란?
  - numpy는 기본 데이터를 변경하지 않고 하나의 배열이 다른 데이터 타입과 형태를 갖는 것 처럼 보이게 만들 수 있는데 이를 view라고한다.
  - 이를 통해 메모리를 효율적으로 사용할 수 있지만 뷰에 데이터를 쓰면 원본 배열도 바뀔 수 있다는 단점이 존재한다. 
  - 따라서, view를 사용할지 deep copy를 사용할지는 사용목적에 따라 다르다. 
- 기본적으로 numpy에서는 slicing이 view를 만들며 shallow copy를 한다. 
```python
import numpy as np
x = np.arange(10)
x
>> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
y = x[1:3]  # deep copy가 아닌 view를 출력한다. 
y
>> array([1, 2])
x[1:3] = [10, 11]
x
array([ 0, 10, 11,  3,  4,  5,  6,  7,  >> 8,  9])
y
>> array([10, 11]) # y도 변경이 된다. 
y[0] = 100
y
>> [100 11]
x # shallow copy가 되면 그대로 같이 변경이 된다. 
>> array([ 0, 100, 11,  3,  4,  5,  6,  7,  >> 8,  9]) 
```

## Dimensional indexing tools
```python
x[..., 0]
>> array([[1, 2, 3],
      [4, 5, 6]])
x[:, :, 0]
>> array([[1, 2, 3],
      [4, 5, 6]])  # 둘은 동일하다.
x[:, np.newaxis, :, :].shape
>> (2, 1, 3, 1)
x[:, None, :, :].shape
>> (2, 1, 3, 1)
# new axis를 통해 축을 확장해줄 수 있다.

```

## Advanced indexing
- numpy에서 slicing은 기본적으로 view를 반환하지만 advance indexing은 copy를 반환한다.
- Advanced indexing은 리스트나 배열을 사용하여 여러 개의 특정 위치를 동시에 선택하는 방식
- 반면, basic indexing은 단일 정수, 슬라이싱 (:), 또는 혼합하여 배열의 특정 요소나 부분 배열을 가져오는 방식
  
```python
x = np.array([[1, 2], [3, 4], [5, 6]])
x[[0, 1, 2], [0, 1, 0]]
>> array([1, 4, 5])
```


```python
import numpy as np
x = np.arange(9).reshape(3, 3)
# 배열과 차원은? 배열의 크기는 9, 차원은 2, 형태는 (3,3)
x
>> array([[0, 1, 2],
          [3, 4, 5],
          [6, 7, 8]])

x[0]
>> array([0,1,2])  # 해당 배열의 부분 배열이 출력된다.
x[0,0] == x[0][0]
>> True
y = x[[1, 2]]  # 정수 배열 인덱싱 사용 (복사 생성)
y
>> array([[3, 4, 5],
          [6, 7, 8]])  # 1행, 2행이 복사되어 새로운 배열로 생성됨
y.base is None
>> True  # `y`는 `x`의 뷰가 아니라 새로운 복사본이다.
# 이를 확인하기 위해 원본 배열 `x`를 수정해본다.
x[[1, 2]] = [[10, 11, 12], [13, 14, 15]]
x
>> array([[ 0,  1,  2],
          [10, 11, 12],
          [13, 14, 15]])
y  # `y`는 `x`와 독립적인 복사본이므로 변경되지 않음
>> array([[3, 4, 5],
          [6, 7, 8]])  
```

reshape도 가능하면 view를 생성한다. 

```python
import numpy as np
x = np.ones((2, 3))
y = x.T  # makes the array non-contiguous
y
>> array([[1., 1.],
       [1., 1.],
       [1., 1.]])
z = y.view()
z.shape = 6
>> Traceback (most recent call last):
   ...
AttributeError: Incompatible shape for in-place modification. Use
`.reshape()` to make a copy with the desired shape.
```

base 속성을 가지고 view인지 copy인지를 구분할 수 있다. 

## Broadcasting
- 보통 연산은 element-by-element로 이뤄진다. 
  - 같은 위치에 있는 element끼리 계산을 한다. 
- Broadcasting은 서로 다른 형태를 가진 배열 간에 산술 연산을 할 수 있게하는 매커니즘
  
- scalar broadcasting 
```python
import numpy as np
a = np.array([1.0, 2.0, 3.0])
b = 2.0
a * b
array([2.,  4.,  6.])
# b가 a와 같은 크기로 broadcast되어 들어간뒤 연산이 이뤄진 것과 동일
```
- scalar b를 a와 같은 크기의 배영로 확장하는 것처럼 처리하지만, 실제로 새로운 배열을 만드는 것은 아님. 

- Broad casting 규칙
1. 각 차원의 크기가 같거나
2. 한쪽 차원의 크기가 1 

이 두 경우에는 broadcasting이 가능하다. 

```python
Image  (3D array): 256 x 256 x 3
Scale  (1D array):             3
Result (3D array): 256 x 256 x 3
```
scale 배열의 크기 3이 마지막 차원과 일치하므로 Broadcasting이 적용됨. 

```python
A      (4D array):  8 x 1 x 6 x 1
B      (3D array):      7 x 1 x 5
Result (4D array):  8 x 7 x 6 x 5
```
- A의 두 번째 차원(1)이 B의 첫 번째 차원(7)으로 확장됨
- A의 마지막 차원(1)이 B의 마지막 차원(5)으로 확장됨.
- 결과적으로 A와 B는 호환되는 크기로 변환이 되어 연산이 가능 


1. 작은 배열이 큰 배열과 연산이 가능하도록 크기가 맞춰짐
   - 브로드캐스팅을 위해 차원이 작은 배열이 자동으로 확장됨

2. 데이터는 실제로 복제되지 않음
   - 사용자 관점: 작은 배열이 복제(copy)된 것처럼 동작함
   - 내부 구현: 메모리 효율을 위해 데이터 복제 없이 연산 수행
     - 복제?
        - 층위 : layer
        - 동작의 층위 : 복제
        - 실제 내부 구현의 층위 : 복제 아닌 효율적인 방식의 낮은 층 

3. 브로드캐스팅이 적용되는 조건
   - 두 배열의 각 차원 크기가 일치하거나, 하나의 차원이 1이면 브로드캐스팅 가능

- input배열은 똑같은 차원을 가질 필요가 없다. 
- 축별로 한쪽이 다른쪽을 copy가능하면 맞춰서 한다. 

---

# 개인 한줄 정리
1. ndarray : 다차원의 동질한 데이터타입을 가지고 요소들로 이루어져있는 배열 객체
2. deep copy vs shallow copy : shallow copy는 복사할 때 id값까지 복사하여 복사한 대상의 값이 변경되면 원본도 변경되지만 deepcopy는 다른 주소로 복사하여 원본에 영향을 주지 않는다.
3. advanced slicing vs basic slicing : advanced slicing은 배열로 slicing을 하는 방식으로 basic slicing의 view(shallow copy)와는 달리 copy(deep copy)가 되어 원본 데이터에 영향을 주지 않는다.
4. broadcasting : 서로 다른 크기의 배열간의 연산을 효율적으로 하기 위한 numpy에서 제공하는 기능으로 작은 배열을 자동으로 확장하여 연산을 가능하게 한다.
---

# 금일 회고
1. 오늘은 NumPy에 대해 심화 학습을 진행했다. 특히, 다양한 슬라이싱 방법 간의 차이에 대해 새롭게 알게 되어 매우 흥미로웠다. 아직 공식 문서를 통해 앞으로 더 깊이 있는 학습을 진행해야겠다고 다짐한 하루였다.